import teacher,student

'''
由于主程序代码无论模块是被导入还是直接被执行都会运行，所以我们需要一种方式在运行时检测该模块是被导入还是被直接执行。
该方式也就是__name__系统变量。如果模块是被导入，__name__的值为模块名字；如果是被直接执行，__name__的值为"__main__"。

'''

def addBook(list: object):
    list.append('book')
    print('可变对象传参时{}'.format(id(list)))

def changeValue(a):
    a = 3
    print('不可变对象传参是{}'.format(id(a)))


'''
命名规则   除了类名用大写开头，单词用驼峰或_隔开，其他变量啊、模块啊，方法啊，函数啊都用小写开头，单词之间用_隔开。
当然常量永远用全大写字母。
'''



if __name__ == '__main__':
    student1 = student.Student(name='曾涛',age=24)
    teacher1 = teacher.Teacher(name='王中才',age=45)
    student1.read_book()
    teacher1.teach_student()
    #可变对象做函数参数，对象可以被修改，使用的引用传递
    list = []
    print('可变对象传参前{}'.format(id(list)))
    addBook(list)
    print(list)
    print('可变对象传参后{}'.format(id(list)))
    a = 10
    print('不可变对象传参前{}'.format(id(a)))
    #不可变对象做函数参数，对象不可被修改，使用的值传递
    changeValue(a)
    print(a)
    print('不可变对象传参后{}'.format(id(a)))


    '''
     传值和传引用的差别

    函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：值传递和引用传递。

    值传递（passl-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。

    引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

     '''

    '''
    结论：python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。
    这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。
    如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象。
    '''





